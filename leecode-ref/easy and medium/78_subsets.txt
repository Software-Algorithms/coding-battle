public class Solution_iteration {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        result.add(new ArrayList<Integer>());
        Arrays.sort(nums);
        for(int i = 0;i<nums.length;i++){
            List<List<Integer>> roundResult = new ArrayList<List<Integer>>();
            for(List<Integer> list:result){
                List<Integer> tmp = new ArrayList<Integer>(list);
                tmp.add(nums[i]);
                roundResult.add(tmp);
            }
            result.addAll(roundResult);
        }
        return result;
    }   
}

public class Solution_recursion {
    public List<List<Integer>> subsets(int[] nums) {    
        List<List<Integer>> finalResult = new ArrayList<List<Integer>>();
        if(nums.length==0) return finalResult;
        else{
            Arrays.sort(nums);
            List<Integer> sub = new ArrayList<Integer>();
            for(int i:nums) sub.add(i);
            finalResult = subsets(sub);
            return finalResult; 
        }
        
    }
    public List<List<Integer>> subsets(List<Integer> sub){
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        if(sub.size()==0) {
            result.add(new ArrayList<Integer>());
            return result;
        }
        else{
            List<Integer> tmp = new ArrayList<Integer>(sub);
            int head = tmp.get(0);
            tmp.remove(0);
            result = subsets(tmp);
            List<List<Integer>> subtmp = new ArrayList<List<Integer>>();
            for(int i = 0; i<result.size();i++){
                subtmp.add(new ArrayList<Integer>(result.get(i))); //way to deep copy a List<List>
            }          
            for(List<Integer> list:result){
                list.add(0,head);
            }
            result.addAll(subtmp);
            return result;
        }
        
    }
    
}

//using pre solution
public class Solution {
    public List<List<Integer>> subsets(int[] nums) {   	
    	List<List<Integer>> finalResult = new ArrayList<List<Integer>>();
    	if(nums.length==0) return finalResult;
    	else{
    		Solution_subsets sol = new Solution_subsets();
    		for(int i=1;i<=nums.length;i++){
    			sol.combine(nums, i);
    		}
    		finalResult.addAll(sol.result); // not safe, should use function to get other class's variable.
    		finalResult.add(new ArrayList<Integer>()); // add empty subset. this can't be done with i=0 in the iteration above
    		return finalResult;   		
    	}
    	
    }
}

class Solution_subsets {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    public List<List<Integer>> combine(int[] wholeSet, int k) {
    	int n = wholeSet.length;
    	if(n==0||k==0||n<k) return result;
        else{
            List<Integer> nums = new ArrayList<Integer>();
            for(int i=1;i<=n;i++) nums.add(wholeSet[i-1]);
            List<Integer> oneCombination = new ArrayList<Integer>();
            combine(nums, oneCombination,k);
            return result;
        }               
    }
    
    public void combine(List<Integer> nums, List<Integer> curr, int k){
        if(curr.size()==k-1){
            for(int i:nums){
                List<Integer> tmp = new ArrayList<Integer>(curr); // need to new a copy cuz we will add it to result
                tmp.add(i);
                result.add(tmp);                
            }
            return;
        }
        else{
            for(int i:nums){
                List<Integer> newnums = new ArrayList<Integer>(nums);
                //unlike permutaion, it's combination, so when we choose i as start, then only choose nums>i as selection set.
                //cuz nums<i have already been generated. So just remove all nums<=i in new nums set.
                //for(int j=0;j<=i;j++) newnums.remove((Integer) j);//differentiate arraylist.remove(int index) and arraylist.remove(Object n)
                                                                  //better using HashSet
                for(int j:nums) if(j<=i) newnums.remove((Integer) j); // to customize for this problem, it's an array not generated by n.
                curr.add(i);
                combine(newnums,curr,k);
                curr.remove(curr.size()-1); //since each time we didn't change curr finally, so we don't need to 
                                            //new a copy of curr                
            }
        }
    }
}