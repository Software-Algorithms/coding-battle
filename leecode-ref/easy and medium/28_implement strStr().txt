public class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), k = needle.length();
        if(n<k) return -1;
        if(k==0) return 0;
        for(int i=k-1;i<n;i++){
            int j = i, curr = k-1;
            while(haystack.charAt(j)==needle.charAt(curr)){
                j--;
                curr--;
                if(curr<0) break;
            }
            if(curr<0) return i-k+1;
        }
        return -1;
        
    }
}

http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/
http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/
//the-knuth-morris-pratt-algorithm
class Solution_implementKMP {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), k = needle.length();
        if(n<k) return -1;
        if(k==0) return 0;
        int[] lps = new int[k];
        buildPattern(lps,needle);
        int partialMatchLength = 0;
        for(int i=0;i<n;){
            if(haystack.charAt(i)==needle.charAt(partialMatchLength)){
                if(partialMatchLength==k-1) return i-partialMatchLength;
                partialMatchLength++;
                i++;
            }
            else{
                if(partialMatchLength>0) partialMatchLength = lps[partialMatchLength-1];
                else i++;
            }
            
        }
        return -1;
    }
    
    public void buildPattern(int[] lps, String needle){
        lps[0] = 0;
        int i = 1, currLength = 0; //current length of longest prefix suffix
        while(i<lps.length){
            if(needle.charAt(i)==needle.charAt(currLength)){
                currLength++;
                lps[i] = currLength;
                i++;
            }
            else{
                if(currLength!=0) currLength = lps[currLength-1];
                else{
                    lps[i] = 0;
                    i++;
                }
            }
        }
    }
}

public Solution{
  void computeLPSArray(char *pat, int M, int *lps)
  {
      int len = 0;  // lenght of the previous longest prefix suffix
      int i;
   
      lps[0] = 0; // lps[0] is always 0
      i = 1;
   
      // the loop calculates lps[i] for i = 1 to M-1
      while (i < M)
      {
         //example "abababca" and i==5, len==3. The longest prefix suffix is "aba", when pat[i]==pat[len],
         //we get new prefix "abab" and new suffix "abab", so increase length of  current lps by 1 and go to next iteration. 
         if (pat[i] == pat[len])
         {
           len++;
           lps[i] = len;
           i++;
         }
         else // (pat[i] != pat[len])
         {
           if (len != 0)
           {
             //This is tricky. Consider the example "ababe......ababc", i is index of 'c', len==4. The longest prefix suffix is "abab",
             //when pat[i]!=pat[len], we get new prefix "ababe" and suffix "ababc", which are not equal. 
             //This means we can't increment length of lps based on current lps "abab". We may want to increment it based on
             //the longest prefix suffix with length < len==4, which by definition is lps of "abab". So we set len to lps[len-1],
             //which is 2, means now the lps is "ab". Then check pat[i]==pat[len] again due to the while loop, which is also the reason
             //why we do not increment i here. The iteration of i terminate until len==0 (didn't find lps ends with pat[i]) or found
             //a lps ends with pat[i].
             len = lps[len-1];
   
             // Also, note that we do not increment i here
           }
           else // if (len == 0)
           { // there isn't any lps ends with pat[i], so set lps[i] = 0 and go to next iteration.
             lps[i] = 0;
             i++;
           }
         }
      }
  }  
}


