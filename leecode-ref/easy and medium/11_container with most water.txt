package leecode;

public class Solution {
     public int maxArea(int[] height) {
        int left = 0, right = height.length-1;
        int area = 0;
        while(left<right){
            if(height[left]<=height[right]){
                area = Math.max(height[left]*(right-left),area);
                left++;
            }
            else{
                area = Math.max(height[right]*(right-left),area);
                right--;
            }
        }
        return area;        
    }
}

//These solutions are for containing most water using all the vertical lines
class Solution_containMostWater {
    public int maxArea(int[] height) {
    	int left = 0, right = height.length-1;
    	int area = 0;
    	int cutoff = 0;
    	while(left<right){
    		if(height[left]<=height[right]){
    			area += Math.max((height[left]-cutoff),0)*(right-left);
    			cutoff = Math.max(cutoff,height[left]);
    			left++;
    		}
    		else{
    			area += Math.max((height[right]-cutoff),0)*(right-left);
    			cutoff = Math.max(cutoff,height[right]);
    			right--;
    		}
    	}
    	return area;    	
    }
    
    public int maxArea_StackOverFlow(int[] height, int a, int b, int cutoff){
    	if(a>=b) return 0;
    	else{
    		int area = 0;
    		if(height[a]<=height[b]){
    			area += Math.max((height[a]-cutoff),0)*(b-a);
    			int newCutoff = Math.max(cutoff,height[a]);
    			area += maxArea_StackOverFlow(height, a+1,b,newCutoff);
    		}
    		else{
    			area += Math.max((height[b]-cutoff),0)*(b-a);
    			int newCutoff = Math.max(cutoff,height[b]);
    			area += maxArea_StackOverFlow(height, a,b-1,newCutoff);
    		}
    		return area;
    	}
    }
}

class Solution_containMostWater1 {
    public int maxArea(int[] height) {
        if(height.length<=1) return 0;
        else{
            int[] area = new int[height.length];
            area[0] = 0;
            for(int i = 1;i<height.length;i++){
                int j = i-1;
                while(j>=0&&height[i]>height[j]){
                    j--;
                }
                if(j<0) area[i] = area[i-1] + height[i-1];
                else area[i] = area[j] + height[i]*(i-j);    
                }
            return area[height.length-1];
            }			
        }      
}

public class containMostWater {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Solution_containMostWater sol = new Solution_containMostWater();
		int [] test = {6,4,7,9,14,6,9};
		int i = sol.maxArea(test);
		System.out.println(i);
	}

}


public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();
        if (nums == null || nums.length == 0)
            return res;

        res.add(new LinkedList<Integer>());

        for (int i: nums){
            int size = res.size();
            while(size-- > 0){
                List<Integer> l = res.remove();
                for (int j = 0; j < l.size(); j++){
                    List<Integer> newList = new LinkedList<Integer>(l);
                    newList.add(j,i);
                    res.add(newList);
                }
                l.add(i);
                res.add(l);
            }
        }

        return res;
    }
}