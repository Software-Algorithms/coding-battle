/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
/* for the follow up, we need to add a int count for each TreeNode, to record how many left children it has, so when we are looking for the kth smallest element, we just find it level by level and do some math thing, the complextiy will be O(height of BST). when inserting or deleting element, beside adjusting the reference, we also maintain the count, for example, do nothing to its children, add 1 to all its ancestors
*/
 
public class Solution {
    int count = 0;
    int current = 0;
    public int kthSmallest(TreeNode root, int k) {
        inOrderTraversal(root,k);
        return current;
    }
    public void inOrderTraversal(TreeNode root, int k){
        if(count==k) return;
        else{
            if(root.left!=null) inOrderTraversal(root.left, k);
            if(count==k) return; //if count gets to k after traversal of left child, don't go on visit root.
                                 //someone write code without the line above, it seems  simple code, but actually
                                 //they need to traverse the whole tree and waste more time.
            count++;
            if(count==k){
                current = root.val;
                return;
            } 
            if(root.right!=null) inOrderTraversal(root.right, k);
        }
    }
}

//DFS:
    public int kthSmallest(TreeNode root, int k) {
        int count = countNodes(root.left);
        if (k <= count) {
            return kthSmallest(root.left, k);
        } else if (k > count + 1) {
            return kthSmallest(root.right, k-1-count); // 1 is counted as current node
        }

        return root.val;
    }

    public int countNodes(TreeNode n) {
        if (n == null) return 0;

        return 1 + countNodes(n.left) + countNodes(n.right);
    }

//DFS2: (actually I think it should be InOrderTraversal)
    private static int number = 0;
    private static int count = 0;

    public int kthSmallest(TreeNode root, int k) {
        count = k;
        helper(root);
        return number;
    }

    public void helper(TreeNode n) {
        if (n.left != null) helper(n.left);
        count--;
        if (count == 0) {
            number = n.val;
            return;
        }
        if (n.right != null) helper(n.right);
    }

//BFS: Actually this is DFS
    public int kthSmallest(TreeNode root, int k) {
        Stack<TreeNode> st = new Stack<>();

        while (root != null) {
            st.push(root);
            root = root.left;
        }

        while (k != 0) {
            TreeNode n = st.pop();
            k--;
            if (k == 0) return n.val;
            TreeNode right = n.right;
            while (right != null) {
                st.push(right);
                right = right.left;
            }
        }

        return -1; // never hit if k is valid
    }
