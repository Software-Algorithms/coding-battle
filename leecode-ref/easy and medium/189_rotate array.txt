//Time complexity O(n), extra space cost O(1)

    public class Solution {
        public void rotate(int[] nums, int k) {
            k %= nums.length;
            if(k<=0) return;
            int index = k, loopHead = 0, curr = nums[0];
            //1. index is the index of the element we will update in each iteration. 
            //2. loopHead is head of a loop (if exist) for index since each time we
            // move index k steps further.
            //3. curr is the value got from previous iteration nums[preIndex] and 
            //for updating nums[index]
            for(int count=0;count<nums.length;count++){
                if(index==loopHead){ //loop detected
                    nums[index] = curr; //set the value of loopHead.
                    loopHead++; //move 1 step further to jump out of loop
                    curr = nums[++index]; //This is the head of new loop
                    index = (index+k)%nums.length;
                }
                else{ //each time go k steps further
                    int tmp = nums[index];
                    nums[index] = curr;
                    curr = tmp;
                    index = (index+k)%nums.length;
                }
            }
        }
    }

//others' solution by reverse twice.
public class Solution {
    public void rotate(int[] nums, int k) {
       int end = nums.length;
        k=k%end;// to check for outofbounds when k >= nums.length
        rotate(nums,0,end-k-1);//reverse one half of the array
        rotate(nums,end-k,end-1);//reverse other half of the array
        rotate(nums,0,end-1);//reverse whole array  
    }
    public void swap(int[] nums,int a,int b){
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    public void rotate(int[] nums,int start,int end){
        for(int i = start;i<=(start+end)/2;i++){
            swap(nums,i,(start+end)-i);
        }
    }


}

/*
public class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        if(k<=0) return;
        int[] nums2 = new int[nums.length];
        int index = 0;
        for(int i = nums.length-k;i<nums.length;i++){
            nums2[index++] = nums[i];
        }
        for(int i = 0;i<nums.length-k;i++){
            nums2[index++] = nums[i];
        }
        for(int i = 0;i<nums.length;i++){
            nums[i] = nums2[i];
        }
        //nums = nums2. //This does NOT word cuz rotate(int[] nums, int k) the nums is a copy of reference, it doesn't change the reference
        //of nums outside the function.
    }
}
*/

use swap() to process a path.