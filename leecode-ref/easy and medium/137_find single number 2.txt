package leecode;

import java.util.*;

// satisfy the time complexity requirement but use extra memory for hashmap
class Solution1_findSingleNum2 {
    public int singleNumber(int[] nums) {
        Map<Integer,String> map = new HashMap<Integer,String>();
        for(int i = 0; i<nums.length; i++){
            if((map.get(nums[i])=="Single") ||(map.get(nums[i])=="Duplicate")){
                map.put(nums[i],"Duplicate");
            }
            else{
                map.put(nums[i],"Single");
            }
        }
        for(int j =0 ;j<nums.length;j++){
            if(map.get(nums[j])=="Single"){
                return nums[j];
            }
        }
        return 0;
    }
}

class Solution2_findSingleNum2 {
    public int singleNumber(int[] nums) {
        int x1 =0;
        int x2 =0;
        int mask; // follow the way to make mask as the 2-digit of 3
        for(int i:nums){
            x2 ^= (x1&i); //only when x1 and i are both 1 we should set it to 1
            x1 ^= i; // use ^ to make sure when i is 0, x1 doesn't change
                      // we can't use | cuz if x1 and i are both 1 we need to make x1 to 0
            mask = ~(x1&x2); //cuz 2-digit representation for 3 is '11', so use x1&x2 to make mask
            x2 &= mask;
            x1 &= mask;//use mask to set x1 and x2 back to 0 when the count reach 3
        }
        return x1; //the numbers occur 3 time make no contribution to x1 and x2,
                   //the number occurs 1 time just make contribution to x1, so return x1;
    }
}

//what a fucking solution!!!
public int singleNumber(int[] A) {
    int ones = 0, twos = 0;
    for(int i = 0; i < A.length; i++){
        ones = (ones ^ A[i]) & ~twos;
        twos = (twos ^ A[i]) & ~ones;
    }
    return ones;
}

class Solution3_findSingleNum2 {
    public static int singleNumber(int[] nums) {
        int[] count = new int[32];
        for(int i:nums){
            for(int j = 31; j>=0;j--){
                if((i&1)==1)count[j]+=1;
                i >>= 1;
                if(count[j]==3)count[j]=0;
            }
        }
        int singleNum = 0;
        for(int k = 0; k<32; k++){ //retrieve the single number from count
            singleNum |= count[k];
            if(k!=31) singleNum = singleNum<<1; //for last bit, don't need to move to the left
        }
        return singleNum;
    }
}

public class findSingleNum2 {

    public static void main(String[] args) {
        int[] test = new int[1];
        test[0] = 1;
        int i = Solution3_findSingleNum2.singleNumber(test);
        System.out.println(i);

    }

}
