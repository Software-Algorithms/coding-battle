/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

// O(n) solution. How to build a path to node in a tree
public class Solution {
	List<TreeNode> res = new LinkedList<TreeNode>();
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==p||root==q) return root;
        else{
        	findPath(root,p,new int[1]);
        	List<TreeNode> pPath = new LinkedList<TreeNode>(res);
        	res.clear();
        	findPath(root,q,new int[1]);
        	List<TreeNode> qPath = res;
        	int i = 1;
        	for(i = 1;i<Math.min(pPath.size(),qPath.size());i++)  	
        		if(pPath.get(i)!=qPath.get(i)) return pPath.get(i-1);
        	return pPath.get(i-1);
        }
    }
    
    public void findPath(TreeNode root, TreeNode p, int[] found){
    	if(root==null) return;
    	else if(root==p){
    		found[0] = 1;
    		res.add(root);
            return;
    	}
    	else{
    		res.add(root);
    		findPath(root.left,p,found);
    		if(found[0]==1) return;
    		else{
    			while(res.get(res.size()-1)!=root) res.remove(res.size()-1);
    			findPath(root.right,p,found);
        		if(found[0]==1) return;
        		else{
        			while(res.get(res.size()-1)!=root) res.remove(res.size()-1);
        			res.remove(res.size()-1);
        			return;
        		}
    		}
    	}
    } 
}

//don't use meaningless recursion for the "if" clause, use boolean variable to record them
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==p||root==q) return root;
        boolean leftInd = isAncestor(root.left,p);
        boolean rightInd = isAncestor(root.left,q);
        if(leftInd){
            if(rightInd) return lowestCommonAncestor(root.left,p,q);
            else return root;
        }
        else{
            if(!rightInd) return lowestCommonAncestor(root.right,p,q);
            else return root;
        }
    }
    
    public boolean isAncestor(TreeNode root, TreeNode p){
        if(root==null) return false;
        else if(root==p) return true;
        else return isAncestor(root.left,p)||isAncestor(root.right,p);
    }
} 

//example: meaningless recursion for the "if" clause. So it could cause time limited exceed.
//but it's tricky for leecode to deal with the time complexity: 3 times of call to isAncestor() will
//cause time limited exceed but 2 times of call would not. So weird.
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==p||root==q) return root;
        else if(isAncestor(root.left,p)){
            if(isAncestor(root.left,q)) return lowestCommonAncestor(root.left,p,q);
            else return root;
        }
        else{
            if(isAncestor(root.right,q)) return lowestCommonAncestor(root.right,p,q);
            else return root;
        }
    }
    
    public boolean isAncestor(TreeNode root, TreeNode p){
        if(root==null) return false;
        else if(root==p) return true;
        else return isAncestor(root.left,p)||isAncestor(root.right,p);
    }
}

//other's solution, example of how to use void function to implement boolean function
public class Solution {
    boolean foundP = false;
    boolean foundQ = false;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == p || root == q)
            return root;
        prefix(root.left, p, q);
        if(foundP && foundQ) {
            foundP = foundQ = false;
            return lowestCommonAncestor(root.left, p, q);
        } else if(!foundP && !foundQ)
            return lowestCommonAncestor(root.right, p, q);
        return root;
    }

    void prefix(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null)
            return;
        if(root == p)
            foundP = true;
        else if(root == q)
            foundQ = true;

        prefix(root.left, p, q);
        prefix(root.right, p , q);
    }
} 

//other's elegant solution.
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null||root == p || root == q) return root;
        TreeNode l = lowestCommonAncestor(root.left,p,q);
        TreeNode r = lowestCommonAncestor(root.right,p,q);
        if(l != null && r != null) return root;
        return l != null ? l:r;
    }
}

