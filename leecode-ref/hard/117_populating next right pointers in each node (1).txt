/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */

//It's a BFS traversal. The curr pointer is the current level traveler and head is the left most element at next level and the tail is the right most element at next level till now. We move curr pointer at current level and populate the the next-link at its children level. (Here the gist is we can move curr to its next because this relationship was already populated in the previous round). 

public class Solution {
    public void connect(TreeLinkNode root) {
        TreeLinkNode curr = root;
        TreeLinkNode head = null, tail = null;
        while(curr!=null) {
            if(curr.left!=null) {
                if(tail!=null) {
                    tail.next = curr.left;
                    tail = tail.next;
                }
                else {
                    head = curr.left;
                    tail = head;
                }
            }
            if(curr.right!=null) {
                if(tail!=null) {
                    tail.next = curr.right;
                    tail = tail.next;
                }
                else {
                    head = curr.right;
                    tail = head;
                }
            }
            if(curr.next!=null) curr = curr.next;
            else {
                curr = head;
                head = null;
                tail = null;
            }
        }
    }
}

/*
public class Solution {
    public void connect(TreeLinkNode root) {
        if(root==null) return; //||root.left==null&&root.right==null
        connect(root.left);
        connect(root.right);
        merge(root.left,1,root.right,new int[1]);
    }
    
    public void merge(TreeLinkNode rootL, int currDepth, TreeLinkNode rootR, int[] visitedDepth){
        if(rootL==null || rootR==null) return;
        if(currDepth> visitedDepth[0]) {
            rootL.next = rootR;
            visitedDepth[0]++;
        }
        merge(rootL.right,currDepth+1,rootR.left,visitedDepth);
        merge(rootL.right,currDepth+1,rootR.right,visitedDepth);
        merge(rootL.left,currDepth+1,rootR.left,visitedDepth);
        merge(rootL.left,currDepth+1,rootR.right,visitedDepth);
    }
}
*/
