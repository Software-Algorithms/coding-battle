//elegant O(n) time solution.
public int longestValidParentheses(String s) {
    Stack<Integer> st = new Stack<Integer>();
    int maxLen = 0;
    int curLen = 0;
    for(int i = 0; i < s.length();i++) {
        if(s.charAt(i) == '(') {
            st.push(curLen);
            curLen = 0;
        } else if (s.charAt(i) == ')') {
            if(st.isEmpty()) {
                curLen = 0;
            } else {
                curLen = curLen + st.pop() + 2;
                if(curLen > maxLen) maxLen = curLen;
            }
        }
    }
    return maxLen;
}

//another O(n) using stack to store position of '('
public class Solution {
    public int longestValidParentheses(String s) {
        if(s == null || s.length() <= 1){
            return 0;
        }
        int start = -1;
        int res = 0;
        LinkedList<Integer> stack = new LinkedList<Integer>();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i) == '('){
                stack.push(i);
            }else{
                if(!stack.isEmpty()){
                    stack.pop();
                    if(!stack.isEmpty()){
                        res = Math.max(res,i-stack.peek()); //"(()(()())". can's use int tmp = stack.pop(); i-tmp+1, need to capture the () before tmp, whose start should be just at stack.peek();

                    }else{
                        res = Math.max(res,i-start);
                    }
                }else{
                    start = i;
                }
            }
        }
        return res;
    }
}

//When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses.
//only when all left parentheses and right parentheses pair out we count the length,
//and for (((()) in forward checking it won't count, but in backward checking it
//would.
public class Solution {
    int longestValidParentheses(string s) {
        int longest = 0;
        int extra=0;
        int length=0;
        for(int i=0; i<s.size(); i++) {
            if(s[i] == '(') {
                extra++;
                length++;
            }
            else {
                if(extra>0) {
                    extra--;
                    length++;
                    if(extra == 0)
                        longest = max(longest, length);
                }
                else {
                    extra = 0;
                    length=0;
                }
            }
        }
        length = 0;
        extra=0;
        for(int i=s.size()-1; i>=0; i--) {
            if(s[i] == ')') {
                extra++;
                length++;
            }
            else {
                if(extra>0){
                    extra--;
                    length++;
                    if(extra == 0)
                        longest = max(longest, length);

                }
                else {
                    extra = 0;
                    length=0;
                }
            }
        }
        return longest;
    }
}


public class Solution {
    public int longestValidParentheses(String s) {
        if(s.length()==0) return 0;
        int maxLen = 0;
        for(int i = 0; i < s.length(); i++) {
            int curr = maxValidLength(s,i);
            if(curr > maxLen) maxLen = curr; 
        }
        return maxLen;
    }
    
    public int maxValidLength(String s, int end) {
        int count = 0;
        int begin = end + 1;
        for(int i = end; i >= 0; i--){
            if(s.charAt(i)=='(') {
                count -= 1;
                if(count==0) begin = i;
                else if(count<0) break;
            }
            else if(s.charAt(i)==')') {
                count += 1;
            }
        }
        return end - begin + 1;
    }
}