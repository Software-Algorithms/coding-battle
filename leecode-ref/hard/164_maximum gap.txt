public class Solution {
    public int maximumGap(int[] nums) {
        if(nums.length<2) return 0;
        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
        for(int num:nums){
            if(num>max) max = num;
            if(num<min) min = num;
        }
        double len = (double)(max-min)/(double)(nums.length-1); //at least N holes, so divide N-1 to get N //holes. [min,min+len),[min+len,min+len*2),...[max,max]. Since if N holes and N numbers, it either //lead to at least one hole empty (general case) or each hole contain one number. In the latter //case, this algorithm also produce the right answer. More than N holes are always right.
        int[] minInHole = new int[nums.length];
        int[] maxInHole = new int[nums.length];
        for(int i=0;i<nums.length;i++){
            minInHole[i] = Integer.MAX_VALUE;
            maxInHole[i] = Integer.MIN_VALUE;
        }
        for(int num:nums){
            int index = (int)((num-min)/len);
            if(num<minInHole[index]) minInHole[index] = num;
            if(num>maxInHole[index]) maxInHole[index] = num;
        }
        int preMax = maxInHole[0];
        int gap = 0;
        for(int i=1;i<minInHole.length;i++){
            //if(i!=minInHole.length-1&&minInHole[i]==Integer.MAX_VALUE) continue; //empty holes.
            //i!=minInHole.length-1 to cover the case the array contains Integer.MAX_VALUE and it falls into last hole.
            //it's weird though. It can pass OJ when we have N holes, can't pass when N*2+1 holes. Maybe due to double
            //multiply and division.
            if(minInHole[i]!=max&&minInHole[i]==Integer.MAX_VALUE) // now there is no problem.
            if(minInHole[i]-preMax>gap) gap = minInHole[i]-preMax;
            preMax = maxInHole[i];
        }
        return gap;
    }
}
