public class Solution {
    public List<Interval> merge(List<Interval> intervals) {
        TreeSet<Interval> set = new TreeSet<Interval>(new ComparatorInter()); //TreeSet is also a none-duplicate set, so need to compare end
    	set.addAll(intervals);
    	intervals.clear();
    	intervals.addAll(set);
        int i = 0;
        List<Integer> toDel = new ArrayList<Integer>();
        while(i < intervals.size()) {
            Interval itv = intervals.get(i);
            int j = i + 1;
            while(j < intervals.size() && itv.end >= intervals.get(j).start) {
                if(itv.end < intervals.get(j).end) itv.end = intervals.get(j).end;
                toDel.add(j);
                j++;
            }
            i = j;
        }
        for(int k = toDel.size()-1; k >= 0; k--) intervals.remove((int)toDel.get(k)); //
        return intervals;
    }
}

class ComparatorInter implements Comparator<Interval>  
{  
    @Override  
    public int compare(Interval o1, Interval o2)  
    {  
        if (o1.start > o2.start) return 1;    
        else if (o1.start < o2.start) return -1;   
        else {  
            if(o1.end > o2.end) return 1;
            else if(o1.end < o2.end) return -1;
            else return 0;
        }  
    }  
}


public class Solution {
    public List<Interval> merge(List<Interval> intervals) {
        Collections.sort(intervals, new Comparator<Interval>(){
            @Override
            public int compare(Interval obj0, Interval obj1) {
                return obj0.start - obj1.start;
            }
        });
        
        for(int i = 0; i < intervals.size();) {
            int j = i + 1;
            while(j < intervals.size() && intervals.get(i).end >= intervals.get(j).start) {
                if(intervals.get(i).end < intervals.get(j).end) intervals.get(i).end = intervals.get(j).end;
                intervals.remove(j);
            }
            i = j;
        }
        return intervals;
    }
}