//This elegant code use DFS to compute it in one traversal, just update the global max when you finished traversal
//of left and right child, the max path including root should be root.val + left + right, if left or right is negative
//just ignore them done by Math.max(helper(root.left), 0). Compare this path with the previous max got from its children.
public class Solution {
    int max = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        helper(root);
        return max;
    }

    // helper returns the max branch 
    // plus current node's value
    int helper(TreeNode root) {
        if (root == null) return 0;

        int left = Math.max(helper(root.left), 0);
        int right = Math.max(helper(root.right), 0);

        max = Math.max(max, root.val + left + right);

        return root.val + Math.max(left, right);
    }
} 
 
 
/*
public class Solution {
    Map<TreeNode,Integer> singlePath = new HashMap<TreeNode,Integer>();
    public int maxPathSum(TreeNode root) {
        if(root==null) return 0;
        if(root.left==null&&root.right==null) return root.val;
        Map<TreeNode,Integer> map = new HashMap<TreeNode,Integer>();
        return helper(root,map);
    }
    
    public int helper(TreeNode root, Map<TreeNode,Integer> map) {
        if(root==null) return 0;
        if(map.containsKey(root)) return map.get(root);
        int res = 0;
        if(root.left==null&&root.right==null) res = root.val;
        else{
            int l = maxSinglePathFromRoot(root.left); //the max single path starts from root.left.
            int r = maxSinglePathFromRoot(root.right);
            int withRoot = root.val; //case 1, the path contain root.
            if(l>0) withRoot += l; 
            if(r>0) withRoot += r;
            int left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
            if(root.left!=null) left = helper(root.left,map);
            if(root.right!=null) right = helper(root.right,map);
            res = withRoot > left ? (withRoot > right ? withRoot : right) : (left > right ? left : right);
        }
        map.put(root,res);
        return res;
    }
    
    
    public int maxSinglePathFromRoot(TreeNode root){ //find a path starts from root and go down.
        if(root==null) return Integer.MIN_VALUE;
        if(singlePath.containsKey(root)) return singlePath.get(root);
        int res = root.val;
        if(root.left==null&&root.right==null) res = root.val;
        else{
            int left = Integer.MIN_VALUE, right = Integer.MIN_VALUE;
            if(root.left!=null) left = maxSinglePathFromRoot(root.left);
            if(root.right!=null) right = maxSinglePathFromRoot(root.right);
            int bigger =  left > right ? left : right;
            if(bigger>0) res += bigger;
        }
        singlePath.put(root,res);
        return res;
    }
}
*/