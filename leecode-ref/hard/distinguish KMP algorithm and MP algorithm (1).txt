//This is KMP algorithm. It's more effective.
//KMP not only build jump table for prefix matching, but also optimize it to avoid recheck the same character when jump back. ex, c[n] is not match, you jump to check c[lps[n]], since c[lps[n]] == c[n], exactly not match, need jump again. This jump is done in next[] table, so when do the matching, no need to jump and jump.

class Solution {
public:
    void get_next(string &pat, vector<int> &next){
        int i = 0, j = -1, p_len = pat.length();
        next[0] = - 1;
        while( i < p_len){
            if ( j == -1 || pat[i] == pat[j]){
                i ++;
                j ++;
                if (pat[i] != pat[j]) next[i] = j;
                else next[i] = next[j];
            }
            else j = next[j];
        }
    }
    string shortestPalindrome(string s) {
        string s_rev = s;
        reverse(s_rev.begin(), s_rev.end());
        int s_len = s.length();
        vector<int> next(s_len + 2, 0);
        get_next(s, next);
        int i = -1, j = -1;
        while( i < s_len){
            if( j == -1 || s_rev[i] == s[j]){
                i ++;
                j ++;
            }
            else j = next[j];
        }
        return s_rev.substr(0, s_len - j) + s;
    }
};

//This is MP algorithm:
class Solution_implementKMP {
    public int strStr(String haystack, String needle) {
        int n = haystack.length(), k = needle.length();
        if(n<k) return -1;
        if(k==0) return 0;
        int[] lps = new int[k];
        buildPattern(lps,needle);
        int partialMatchLength = 0;
        for(int i=0;i<n;){
            if(haystack.charAt(i)==needle.charAt(partialMatchLength)){
                if(partialMatchLength==k-1) return i-partialMatchLength;
                partialMatchLength++;
                i++;
            }
            else{
                if(partialMatchLength>0) {
                    partialMatchLength = lps[partialMatchLength-1];
                }
                else i++;
            }

        }
        return -1;
    }

    public void buildPattern(int[] lps, String needle){
        lps[0] = 0;
        int i = 1, currLength = 0; //current length of longest prefix suffix
        while(i<lps.length){
            if(needle.charAt(i)==needle.charAt(currLength)){
                currLength++;
                lps[i] = currLength;
                i++;
            }
            else{
                if(currLength!=0) currLength = lps[currLength-1];
                else{
                    lps[i] = 0;
                    i++;
                }
            }
        }
    }
}