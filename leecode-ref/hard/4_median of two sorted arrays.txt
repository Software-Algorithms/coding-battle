https://leetcode.com/discuss/41621/very-concise-iterative-solution-with-detailed-explanation
//amazing solution
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    int N1 = nums1.size();
    int N2 = nums2.size();
    if (N1 < N2) return findMedianSortedArrays(nums2, nums1);   // Make sure A2 is the shorter one.

    if (N2 == 0) return ((double)nums1[(N1-1)/2] + (double)nums1[N1/2])/2;  // If A2 is empty

    int lo = 0, hi = N2 * 2;
    while (lo <= hi) {
        int mid2 = (lo + hi) / 2;   // Try Cut 2 
        int mid1 = N1 + N2 - mid2;  // Calculate Cut 1 accordingly

        double L1 = (mid1 == 0) ? INT_MIN : nums1[(mid1-1)/2];  // Get L1, R1, L2, R2 respectively
        double L2 = (mid2 == 0) ? INT_MIN : nums2[(mid2-1)/2];
        double R1 = (mid1 == N1 * 2) ? INT_MAX : nums1[(mid1)/2];
        double R2 = (mid2 == N2 * 2) ? INT_MAX : nums2[(mid2)/2];

        if (L1 > R2) lo = mid2 + 1;     // A1's lower half is too big; need to move C1 left (C2 right)
        else if (L2 > R1) hi = mid2 - 1;    // A2's lower half too big; need to move C2 left.
        else return (max(L1,L2) + min(R1, R2)) / 2; // Otherwise, that's the right cut.
    }
    return -1;
} 

//https://leetcode.com/discuss/51519/concise-java-solution-o-log-n
public class Solution {
    public static double findMedianSortedArrays(int A[], int B[]) {
        int total = A.length + B.length;
        if(total%2 == 0){
            return (findKth(A,0,B,0,total/2) + findKth(A,0,B,0,total/2+1))/2.0;
        }else{
            return findKth(A,0,B,0,total/2 + 1);
        }
    }
    public static double findKth(int[] A, int A_start, int[] B, int B_start,int k){
        if(A_start >= A.length){
            return B[B_start+k-1];
        }
        if(B_start >= B.length){
            return A[A_start+k-1];
        }
        if(k == 1){
            return Math.min(A[A_start],B[B_start]);
        }
        int AKey = A_start+k/2-1 < A.length ? A[A_start + k/2 -1] : Integer.MAX_VALUE;
        int BKey = B_start+k/2-1 < B.length ? B[B_start + k/2 -1] : Integer.MAX_VALUE;
        if(AKey > BKey){
            return findKth(A,A_start,B,B_start+k/2,k-k/2);
        }else{
            return findKth(A,A_start+k/2,B,B_start,k-k/2);
        }
    }
}

//horrible solution.
public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        if(nums1.length<nums2.length){
            int[] tmp = nums2;
            nums2 = nums1;
            nums1 = tmp;
        }
        int l1 = 0, l2 = 0, r1 = nums1.length-1, r2 = nums2.length-1;
        if(nums1.length==0&&nums2.length==0) return (double)0;
        else if(nums2.length==0) return ((r1-l1)%2==0)?(double)nums1[(l1+r1)/2]:(((double)nums1[(l1+r1)/2]+(double)nums1[1+(l1+r1)/2])/2);
        while(l1<r1&&l2<r2){
            if(r2-l2==1) break;
            double median1 = ((r1-l1)%2==0)?(double)nums1[(l1+r1)/2]:(((double)nums1[(l1+r1)/2]+(double)nums1[1+(l1+r1)/2])/2);
            double median2 = ((r2-l2)%2==0)?(double)nums2[(l2+r2)/2]:(((double)nums2[(l2+r2)/2]+(double)nums2[1+(l2+r2)/2])/2);
            if(median1==median2) return median1;
            else if(median1>median2){
                int delta = (l2+r2)/2-l2;
                l2 += delta;
                r1 -= delta;
            }
            else{
                int delta = ((r2-l2)%2==0)?r2-(l2+r2)/2:r2-((l2+r2)/2+1);
                r2 -= delta;
                l1 += delta;
            }
        }
        if(l2==r2){
            if(l1==r1) return ((double)nums1[l1] + (double)nums2[l2])/2;
            else if((r1-l1)%2==0){ //nums1 has odd amount of nums left
                if(nums2[l2]<nums1[(l1+r1)/2-1]) return ((double)nums1[(l1+r1)/2] + (double)nums1[(l1+r1)/2-1])/2;
                else if(nums2[l2]>nums1[(l1+r1)/2+1]) return ((double)nums1[(l1+r1)/2] + (double)nums1[(l1+r1)/2+1])/2;
                else return ((double)nums1[(l1+r1)/2] + (double)nums2[l2])/2;
            }
            else{
                if(nums2[l2]<nums1[(l1+r1)/2]) return (double)nums1[(l1+r1)/2];
                else if(nums2[l2]>nums1[(l1+r1)/2+1]) return (double)nums1[(l1+r1)/2+1];
                else return (double)nums2[l2];
            }
        }
        else{//r2-l2==1
            if((r1-l1)%2==0){
                if(nums2[l2]>=nums1[(l1+r1)/2+1]) return (double)nums1[(l1+r1)/2+1];
                else if(nums2[r2]<=nums1[(l1+r1)/2-1]) return (double)nums1[(l1+r1)/2-1];
                else if(nums2[l2]>=nums1[(l1+r1)/2]) return (double)nums2[l2];
                else if(nums2[r2]<=nums1[(l1+r1)/2]) return (double)nums2[r2];
                else return (double)nums1[(l1+r1)/2];
            }
            else{
                if(nums2[l2]>=nums1[(l1+r1)/2]&&nums2[r2]<=nums1[(l1+r1)/2+1]) return ((double)nums2[l2]+(double)nums2[r2])/2;
                else if(nums2[l2]<=nums1[(l1+r1)/2]&&nums2[r2]>=nums1[(l1+r1)/2+1]) return ((double)nums1[(l1+r1)/2]+(double)nums1[(l1+r1)/2+1])/2;
                else if(r1-l1>1){
                    if(nums2[r2]<=nums1[(l1+r1)/2+1]&&nums2[r2]>=nums1[(l1+r1)/2-1]) return ((double)nums2[r2]+(double)nums1[(l1+r1)/2])/2;
                    else if(nums2[r2]<nums1[(l1+r1)/2-1]) return ((double)nums1[(l1+r1)/2]+(double)nums1[(l1+r1)/2-1])/2;
                    else if(nums2[l2]>=nums1[(l1+r1)/2]&&nums2[l2]<=nums1[(l1+r1)/2+2]) return ((double)nums2[l2]+(double)nums1[(l1+r1)/2+1])/2; 
                    else return ((double)nums1[(l1+r1)/2+1]+(double)nums1[(l1+r1)/2+2])/2;
                }
                else{
                    if(nums2[l2]>=nums1[l1]){
                        return ((double)nums1[r1]+(double)nums2[l2])/2;
                    } 
                    else return ((double)nums1[l1]+(double)nums2[r2])/2;
                }
            }
        }
    }
}