https://leetcode.com/discuss/5198/a-o-n-2-solution-based-on-largest-rectangle-in-histogram
public class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0) return 0;
        int rows = matrix.length, cols = matrix[0].length;
        int maxArea = 0;
        int[] height = new int[cols+1]; //extra one fake column with height 0 to pop all the left column out at the end.
        for(int i=0; i < rows; i++) {
            Stack<Integer> stack = new Stack<Integer>();
            for(int j=0; j < cols+1; j++) {
                if(j!=cols) {
                    if(matrix[i][j]=='1') height[j]++;
                    else height[j]=0;
                }
                if(stack.isEmpty()||height[stack.peek()]<=height[j]) {
                    stack.push(j);
                }
                else {
                    while(!stack.isEmpty() && height[stack.peek()]>height[j]) {
                        int left = stack.pop(); //the left boundary
                        int area = height[left] * (stack.isEmpty() ? j : j - stack.peek() - 1); 
                        if(area > maxArea) maxArea = area;
                    }
                    stack.push(j);
                }
            }
        }
        return maxArea;
        
    }
}

//https://leetcode.com/discuss/20240/share-my-dp-solution
public class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0) return 0;
        int rows = matrix.length, cols = matrix[0].length;
        int maxArea = 0;
        int[] left = new int[cols], right = new int[cols], height = new int[cols]; //left and right boundary and height.
        for(int j=0; j < cols; j++) right[j] = cols; //important to initial right[j] to right most. 
        for(int i=0; i < rows; i++) {
            for(int j=0; j < cols; j++){
                if(matrix[i][j]=='0') height[j] = 0;
                else height[j]++;
            }
            int currLeft = 0; //left boundary of current row, index is at the first '1' element 
            for(int j=0; j < cols; j++){
                if(matrix[i][j]=='0') {
                    left[j] = 0;
                    currLeft = j + 1;
                }
                else left[j] = left[j] > currLeft ? left[j] : currLeft;
            }
            int currRight = cols; //right boundary of current row, index is at the right of last '1' element for convenience of area compute
            for(int j=cols-1; j>=0; j--) {
                if(matrix[i][j]=='0') {
                    right[j] = cols;
                    currRight = j;
                }
                else right[j] = right[j] < currRight ? right[j] : currRight;
            }
            for(int j=0; j<cols; j++) {
                int area = (right[j]-left[j])*height[j];
                if(area>maxArea) maxArea = area;
            }
        }
        return maxArea;
    }
}


//bad idea. too complicated.
/*
public class Solution {
    public int maximalRectangle(char[][] matrix) {
        if(matrix.length==0) return 0;
        int rows = matrix.length, cols = matrix[0].length;
        int maxArea = 0;
        LeftUp[][] leftUp = new LeftUp[rows][cols];
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < cols; j++) {
                if(i==0||j==0) {
                    leftUp[i][j] = matrix[i][j]=='1' ? new LeftUp(i,j) : null;
                    
                    
                }
                else if(matrix[i][j]=='0') continue;
                else if(matrix[i-1][j]=='0'||matrix[i][j-1]=='0'||matrix[i-1][j-1]=='0') leftUp[i][j] = new LeftUp(i,j);
                else {
                    int yOfLeft = leftUp[i][j-1].y < leftUp[i-1][j].y ? leftUp[i][j-1].y : leftUp[i-1][j].y;
                    int xOfUp = leftUp[i-1][j].x < leftUp[i][j-1].x ? leftUp[i-1][j].x : leftUp[i][j-1].x;
                    int yOfDiag = leftUp[i-1][j-1].y < leftUp[i-1][j].y ? leftUp[i-1][j-1].y : leftUp[i-1][j].y;
                    int xOfDiag = leftUp[i-1][j-1].x < leftUp[i][j-1].x ? leftUp[i-1][j-1].x : leftUp[i][j-1].x;
                    int areaLeft = (i-yOfLeft+1)*(j-leftUp[i][j-1].x+1);
                    int areaUp = (i-leftUp[i-1][j].y+1)*(j-xOfUp+1);
                    int areaDiag = (i-yOfDiag+1)*(j-xOfDiag+1);
                    int localMax = areaDiag>areaLeft ? (areaDiag>areaUp?areaDiag:areaUp) : (areaLeft>areaUp?areaLeft:areaUp);
                    if(localMax==areaLeft) leftUp[i][j] = new LeftUp(leftUp[i][j-1].x,yOfLeft);
                    else if(localMax==areaUp) leftUp[i][j] = new LeftUp(xOfUp,leftUp[i-1][j].y);
                    else leftUp[i][j] = new LeftUp(xOfDiag,yOfDiag);
                    if(localMax>maxArea) maxArea = localMax;
                }
            }
        }
        return maxArea;
    }
}

class LeftUp {
    int x;
    int y;
    LeftUp(int coorX, int coorY) {
        x = coorX;
        y = coorY; 
    }
}
*/